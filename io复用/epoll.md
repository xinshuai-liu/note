# I/O 模型

1. **阻塞式 I/O**  
   当进行 I/O 操作时，如果数据不可用，则调用会阻塞进程直到数据到达。

2. **非阻塞式 I/O**  
   调用会立即返回，无论数据是否可用；若没有数据，则返回 `EAGAIN` 或 `EWOULDBLOCK`。

3. **多路复用 I/O**  
   使用如 `select`、`poll`、`epoll` 等系统调用同时监听多个文件描述符的状态，从而实现高效 I/O 处理。

4. **信号驱动 I/O**  
   利用信号来通知应用程序数据到达或状态改变，进而进行处理。

5. **异步 I/O**  
   应用程序发起 I/O 操作后无需等待完成，操作系统在操作完成后通过回调或事件通知应用程序。

---

# epoll

## 1. 什么是 epoll？

- **定义**  
  Epoll 是 Linux 内核提供的一种基于事件驱动的 I/O 多路复用机制。

- **工作原理**  
  - 通过 `epoll_create()` 创建一个 epoll 实例，内核会维护一个包含所有待检测文件描述符的红黑树和一个就绪链表。
  - 使用 `epoll_ctl()` 将感兴趣的文件描述符及对应的事件（如可读、可写）加入红黑树中，并注册回调函数。
  - 当某个文件描述符的 I/O 状态发生变化时，内核调用相应的回调函数将对应节点插入就绪链表中。
  - 最后，通过 `epoll_wait()` 从内核获取就绪事件列表。

- **触发模式**  
  - **水平触发（LT）**：只要文件描述符处于就绪状态，每次调用 `epoll_wait()` 都会返回该事件。
  - **边沿触发（ET）**：只在状态从非就绪变为就绪时触发一次，不会重复触发，要求 socket 必须设置为非阻塞模式。

---

## 2. 为什么在 epoll 的边沿触发模式下必须设置 socket 为非阻塞？

- **事件触发机制**  
  在 ET 模式下，内核仅在状态发生变化时通知一次。如果 socket 为阻塞模式，当应用程序未能一次性读取完数据时，会导致阻塞，从而错过后续数据到达的通知。

---

## 3. epoll 为什么高效？

- **内存映射**  
  将用户空间的一块地址与内核空间的一块地址同时映射到同一物理内存，减少了数据拷贝的开销。

- **高效数据结构**  
  利用红黑树存储所有待检测的套接字，查找、插入和删除操作都具有较高的效率。

- **事件驱动**  
  采用事件驱动机制，只有发生 I/O 事件时才通知应用程序，避免了遍历所有文件描述符的开销。

---





